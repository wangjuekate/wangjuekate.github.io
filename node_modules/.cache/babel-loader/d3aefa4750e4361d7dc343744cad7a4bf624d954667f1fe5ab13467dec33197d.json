{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\nconst sections = require('section-matter');\nconst defaults = require('./lib/defaults');\nconst stringify = require('./lib/stringify');\nconst excerpt = require('./lib/excerpt');\nconst engines = require('./lib/engines');\nconst toFile = require('./lib/to-file');\nconst parse = require('./lib/parse');\nconst utils = require('./lib/utils');\n\n/**\n * Takes a string or object with `content` property, extracts\n * and parses front-matter from the string, then returns an object\n * with `data`, `content` and other [useful properties](#returned-object).\n *\n * ```js\n * const matter = require('gray-matter');\n * console.log(matter('---\\ntitle: Home\\n---\\nOther stuff'));\n * //=> { data: { title: 'Home'}, content: 'Other stuff' }\n * ```\n * @param {Object|String} `input` String, or object with `content` string\n * @param {Object} `options`\n * @return {Object}\n * @api public\n */\n\nfunction matter(input, options) {\n  if (input === '') {\n    return {\n      data: {},\n      content: input,\n      excerpt: '',\n      orig: input\n    };\n  }\n  let file = toFile(input);\n  const cached = matter.cache[file.content];\n  if (!options) {\n    if (cached) {\n      file = Object.assign({}, cached);\n      file.orig = cached.orig;\n      return file;\n    }\n\n    // only cache if there are no options passed. if we cache when options\n    // are passed, we would need to also cache options values, which would\n    // negate any performance benefits of caching\n    matter.cache[file.content] = file;\n  }\n  return parseMatter(file, options);\n}\n\n/**\n * Parse front matter\n */\n\nfunction parseMatter(file, options) {\n  const opts = defaults(options);\n  const open = opts.delimiters[0];\n  const close = '\\n' + opts.delimiters[1];\n  let str = file.content;\n  if (opts.language) {\n    file.language = opts.language;\n  }\n\n  // get the length of the opening delimiter\n  const openLen = open.length;\n  if (!utils.startsWith(str, open, openLen)) {\n    excerpt(file, opts);\n    return file;\n  }\n\n  // if the next character after the opening delimiter is\n  // a character from the delimiter, then it's not a front-\n  // matter delimiter\n  if (str.charAt(openLen) === open.slice(-1)) {\n    return file;\n  }\n\n  // strip the opening delimiter\n  str = str.slice(openLen);\n  const len = str.length;\n\n  // use the language defined after first delimiter, if it exists\n  const language = matter.language(str, opts);\n  if (language.name) {\n    file.language = language.name;\n    str = str.slice(language.raw.length);\n  }\n\n  // get the index of the closing delimiter\n  let closeIndex = str.indexOf(close);\n  if (closeIndex === -1) {\n    closeIndex = len;\n  }\n\n  // get the raw front-matter block\n  file.matter = str.slice(0, closeIndex);\n  const block = file.matter.replace(/^\\s*#[^\\n]+/gm, '').trim();\n  if (block === '') {\n    file.isEmpty = true;\n    file.empty = file.content;\n    file.data = {};\n  } else {\n    // create file.data by parsing the raw file.matter block\n    file.data = parse(file.language, file.matter, opts);\n  }\n\n  // update file.content\n  if (closeIndex === len) {\n    file.content = '';\n  } else {\n    file.content = str.slice(closeIndex + close.length);\n    if (file.content[0] === '\\r') {\n      file.content = file.content.slice(1);\n    }\n    if (file.content[0] === '\\n') {\n      file.content = file.content.slice(1);\n    }\n  }\n  excerpt(file, opts);\n  if (opts.sections === true || typeof opts.section === 'function') {\n    sections(file, opts.section);\n  }\n  return file;\n}\n\n/**\n * Expose engines\n */\n\nmatter.engines = engines;\n\n/**\n * Stringify an object to YAML or the specified language, and\n * append it to the given string. By default, only YAML and JSON\n * can be stringified. See the [engines](#engines) section to learn\n * how to stringify other languages.\n *\n * ```js\n * console.log(matter.stringify('foo bar baz', {title: 'Home'}));\n * // results in:\n * // ---\n * // title: Home\n * // ---\n * // foo bar baz\n * ```\n * @param {String|Object} `file` The content string to append to stringified front-matter, or a file object with `file.content` string.\n * @param {Object} `data` Front matter to stringify.\n * @param {Object} `options` [Options](#options) to pass to gray-matter and [js-yaml].\n * @return {String} Returns a string created by wrapping stringified yaml with delimiters, and appending that to the given string.\n * @api public\n */\n\nmatter.stringify = function (file, data, options) {\n  if (typeof file === 'string') file = matter(file, options);\n  return stringify(file, data, options);\n};\n\n/**\n * Synchronously read a file from the file system and parse\n * front matter. Returns the same object as the [main function](#matter).\n *\n * ```js\n * const file = matter.read('./content/blog-post.md');\n * ```\n * @param {String} `filepath` file path of the file to read.\n * @param {Object} `options` [Options](#options) to pass to gray-matter.\n * @return {Object} Returns [an object](#returned-object) with `data` and `content`\n * @api public\n */\n\nmatter.read = function (filepath, options) {\n  const str = fs.readFileSync(filepath, 'utf8');\n  const file = matter(str, options);\n  file.path = filepath;\n  return file;\n};\n\n/**\n * Returns true if the given `string` has front matter.\n * @param  {String} `string`\n * @param  {Object} `options`\n * @return {Boolean} True if front matter exists.\n * @api public\n */\n\nmatter.test = function (str, options) {\n  return utils.startsWith(str, defaults(options).delimiters[0]);\n};\n\n/**\n * Detect the language to use, if one is defined after the\n * first front-matter delimiter.\n * @param  {String} `string`\n * @param  {Object} `options`\n * @return {Object} Object with `raw` (actual language string), and `name`, the language with whitespace trimmed\n */\n\nmatter.language = function (str, options) {\n  const opts = defaults(options);\n  const open = opts.delimiters[0];\n  if (matter.test(str)) {\n    str = str.slice(open.length);\n  }\n  const language = str.slice(0, str.search(/\\r?\\n/));\n  return {\n    raw: language,\n    name: language ? language.trim() : ''\n  };\n};\n\n/**\n * Expose `matter`\n */\n\nmatter.cache = {};\nmatter.clearCache = function () {\n  matter.cache = {};\n};\nmodule.exports = matter;","map":{"version":3,"names":["fs","require","sections","defaults","stringify","excerpt","engines","toFile","parse","utils","matter","input","options","data","content","orig","file","cached","cache","Object","assign","parseMatter","opts","open","delimiters","close","str","language","openLen","length","startsWith","charAt","slice","len","name","raw","closeIndex","indexOf","block","replace","trim","isEmpty","empty","section","read","filepath","readFileSync","path","test","search","clearCache","module","exports"],"sources":["/Users/katewang/Library/CloudStorage/Dropbox/Business_Ideas/GithubWiki_LearningSharing/wangjuekate.github.io/node_modules/gray-matter/index.js"],"sourcesContent":["'use strict';\n\nconst fs = require('fs');\nconst sections = require('section-matter');\nconst defaults = require('./lib/defaults');\nconst stringify = require('./lib/stringify');\nconst excerpt = require('./lib/excerpt');\nconst engines = require('./lib/engines');\nconst toFile = require('./lib/to-file');\nconst parse = require('./lib/parse');\nconst utils = require('./lib/utils');\n\n/**\n * Takes a string or object with `content` property, extracts\n * and parses front-matter from the string, then returns an object\n * with `data`, `content` and other [useful properties](#returned-object).\n *\n * ```js\n * const matter = require('gray-matter');\n * console.log(matter('---\\ntitle: Home\\n---\\nOther stuff'));\n * //=> { data: { title: 'Home'}, content: 'Other stuff' }\n * ```\n * @param {Object|String} `input` String, or object with `content` string\n * @param {Object} `options`\n * @return {Object}\n * @api public\n */\n\nfunction matter(input, options) {\n  if (input === '') {\n    return { data: {}, content: input, excerpt: '', orig: input };\n  }\n\n  let file = toFile(input);\n  const cached = matter.cache[file.content];\n\n  if (!options) {\n    if (cached) {\n      file = Object.assign({}, cached);\n      file.orig = cached.orig;\n      return file;\n    }\n\n    // only cache if there are no options passed. if we cache when options\n    // are passed, we would need to also cache options values, which would\n    // negate any performance benefits of caching\n    matter.cache[file.content] = file;\n  }\n\n  return parseMatter(file, options);\n}\n\n/**\n * Parse front matter\n */\n\nfunction parseMatter(file, options) {\n  const opts = defaults(options);\n  const open = opts.delimiters[0];\n  const close = '\\n' + opts.delimiters[1];\n  let str = file.content;\n\n  if (opts.language) {\n    file.language = opts.language;\n  }\n\n  // get the length of the opening delimiter\n  const openLen = open.length;\n  if (!utils.startsWith(str, open, openLen)) {\n    excerpt(file, opts);\n    return file;\n  }\n\n  // if the next character after the opening delimiter is\n  // a character from the delimiter, then it's not a front-\n  // matter delimiter\n  if (str.charAt(openLen) === open.slice(-1)) {\n    return file;\n  }\n\n  // strip the opening delimiter\n  str = str.slice(openLen);\n  const len = str.length;\n\n  // use the language defined after first delimiter, if it exists\n  const language = matter.language(str, opts);\n  if (language.name) {\n    file.language = language.name;\n    str = str.slice(language.raw.length);\n  }\n\n  // get the index of the closing delimiter\n  let closeIndex = str.indexOf(close);\n  if (closeIndex === -1) {\n    closeIndex = len;\n  }\n\n  // get the raw front-matter block\n  file.matter = str.slice(0, closeIndex);\n\n  const block = file.matter.replace(/^\\s*#[^\\n]+/gm, '').trim();\n  if (block === '') {\n    file.isEmpty = true;\n    file.empty = file.content;\n    file.data = {};\n  } else {\n\n    // create file.data by parsing the raw file.matter block\n    file.data = parse(file.language, file.matter, opts);\n  }\n\n  // update file.content\n  if (closeIndex === len) {\n    file.content = '';\n  } else {\n    file.content = str.slice(closeIndex + close.length);\n    if (file.content[0] === '\\r') {\n      file.content = file.content.slice(1);\n    }\n    if (file.content[0] === '\\n') {\n      file.content = file.content.slice(1);\n    }\n  }\n\n  excerpt(file, opts);\n\n  if (opts.sections === true || typeof opts.section === 'function') {\n    sections(file, opts.section);\n  }\n  return file;\n}\n\n/**\n * Expose engines\n */\n\nmatter.engines = engines;\n\n/**\n * Stringify an object to YAML or the specified language, and\n * append it to the given string. By default, only YAML and JSON\n * can be stringified. See the [engines](#engines) section to learn\n * how to stringify other languages.\n *\n * ```js\n * console.log(matter.stringify('foo bar baz', {title: 'Home'}));\n * // results in:\n * // ---\n * // title: Home\n * // ---\n * // foo bar baz\n * ```\n * @param {String|Object} `file` The content string to append to stringified front-matter, or a file object with `file.content` string.\n * @param {Object} `data` Front matter to stringify.\n * @param {Object} `options` [Options](#options) to pass to gray-matter and [js-yaml].\n * @return {String} Returns a string created by wrapping stringified yaml with delimiters, and appending that to the given string.\n * @api public\n */\n\nmatter.stringify = function(file, data, options) {\n  if (typeof file === 'string') file = matter(file, options);\n  return stringify(file, data, options);\n};\n\n/**\n * Synchronously read a file from the file system and parse\n * front matter. Returns the same object as the [main function](#matter).\n *\n * ```js\n * const file = matter.read('./content/blog-post.md');\n * ```\n * @param {String} `filepath` file path of the file to read.\n * @param {Object} `options` [Options](#options) to pass to gray-matter.\n * @return {Object} Returns [an object](#returned-object) with `data` and `content`\n * @api public\n */\n\nmatter.read = function(filepath, options) {\n  const str = fs.readFileSync(filepath, 'utf8');\n  const file = matter(str, options);\n  file.path = filepath;\n  return file;\n};\n\n/**\n * Returns true if the given `string` has front matter.\n * @param  {String} `string`\n * @param  {Object} `options`\n * @return {Boolean} True if front matter exists.\n * @api public\n */\n\nmatter.test = function(str, options) {\n  return utils.startsWith(str, defaults(options).delimiters[0]);\n};\n\n/**\n * Detect the language to use, if one is defined after the\n * first front-matter delimiter.\n * @param  {String} `string`\n * @param  {Object} `options`\n * @return {Object} Object with `raw` (actual language string), and `name`, the language with whitespace trimmed\n */\n\nmatter.language = function(str, options) {\n  const opts = defaults(options);\n  const open = opts.delimiters[0];\n\n  if (matter.test(str)) {\n    str = str.slice(open.length);\n  }\n\n  const language = str.slice(0, str.search(/\\r?\\n/));\n  return {\n    raw: language,\n    name: language ? language.trim() : ''\n  };\n};\n\n/**\n * Expose `matter`\n */\n\nmatter.cache = {};\nmatter.clearCache = function() {\n  matter.cache = {};\n};\nmodule.exports = matter;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}